# äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°

è¾“å…¥ä¸€ä¸ªæ•´æ•°ï¼Œè¾“å‡ºè¯¥æ•°äºŒè¿›åˆ¶è¡¨ç¤ºä¸­1çš„ä¸ªæ•°ã€‚å…¶ä¸­è´Ÿæ•°ç”¨è¡¥ç è¡¨ç¤ºã€‚

## Solution

```java
public class Solution {

    public int NumberOf1(int n) {
        int count = 0;
        
        while (n != 0) {
            if ((n & 1) == 1) {    // if last bit is 1ï¼ˆæ³¨æ„è¿ç®—ç¬¦ä¼˜å…ˆé¡ºåºï¼‰
                count++;
            }
            
            n = n >>> 1;
        }
        
        return count;
    }
}
```

æ³¨æ„è¿ç®—ç¬¦ `>>` ä¸ `>>>` çš„åŒºåˆ«ã€‚å¯¹äºæ­£æ•°è€Œè¨€äºŒè€…æ²¡ä»€ä¹ˆåŒºåˆ«ã€‚

`>>` æ˜¯ right shiftï¼Œæˆ–è€…ç§°ä½œ ç®—æ•°å³ç§»ä½ (arithmetic right shift)ï¼Œå³ç§»ååœ¨æœ€å·¦è¾¹è¡¥ä¸Šç¬¦å·ä½ï¼ˆæ­£æ•°æ˜¯0ï¼Œè´Ÿæ•°æ˜¯1ï¼‰

`>>>` æ˜¯ unsigned right shiftï¼Œæˆ–è€…ç§°ä½œ é€»è¾‘å³ç§»ä½ (logical right shift)ï¼Œå³ç§»ååœ¨æœ€å·¦è¾¹è¡¥0

> âš ï¸æ³¨æ„ï¼šJavaä¸­å¹¶æ²¡æœ‰ `<<<` è¿ç®—ç¬¦ã€‚

```
~       Unary bitwise complement
<<      Signed left shift
>>      Signed right shift
>>>     Unsigned right shift
&       Bitwise AND
^       Bitwise exclusive OR
|       Bitwise inclusive OR
```

## Solution2

ä¹Ÿå¯ä»¥ç”¨mask = 1ï¼Œä¸æ–­å·¦ç§»maskï¼Œä»å³å‘å·¦ğŸ‘ˆä¾æ¬¡åˆ¤æ–­ n çš„æ¯ä¸ªbitä½ã€‚

```java
public class Solution {

    public int NumberOf1(int n) {
        int count = 0;
        
        int mask = 1;
        while (mask != 0) {
            if ((n & mask) != 0) {    // æ³¨æ„ä¸èƒ½å†™æˆ == 1
                count++;
            }
            
            mask = mask << 1;
        }
        
        return count;
    }
}
```

